#!/usr/bin/env swift
import Foundation
import ScriptingBridge

/**
 Generic FileHandle wrapper with custom init and write implementations.
 */
class FileAppender {
    private var fileHandle: FileHandle

    /**
     Open file at `path`, creating blank file (with no contents and default attributes) if needed, and seek to EOF.

     - parameter path: path to file, which may or may not already exist
     */
    init(_ path: String) {
        // can't open a non-existent file for writing (um, weird?)
        if !FileManager.default.fileExists(atPath: path) {
            // create it if it doesn't exist
            // FileManager#createFile returns Bool => true if successful or already exists
            // (which might be useful?), but we'll just fail hard at FileHandle constructor step
            FileManager.default.createFile(atPath: path, contents: nil, attributes: nil)
        }
        // now open it (failing hard on I/O error, including no file existing at path)
        fileHandle = FileHandle(forWritingAtPath: path)!
        // seek to the end manually (no option to open in append mode?)
        fileHandle.seekToEndOfFile()
    }

    /**
     Append the given string to the opened file.

     - parameter line: native string to write to the file, encoded as UTF-8. Should already include newline.
     */
    func write(_ line: String) {
        // fail hard if line cannot be serialized as UTF-8
        let data = line.data(using: .utf8)!
        fileHandle.write(data)
    }
}

/*
 The following protocols are a subset of the output generated by these commands:

     sdef /Applications/iTunes.app | sdp -fh --basename iTunes  # produces "iTunes.h"
     python sbhc.py iTunes.h  # produces "iTunes.swift"

 Thanks to https://github.com/tingraldi/SwiftScripting for the sbhc.py script.

 The only protocols actively used are `iTunesApplication` and `iTunesTrack`
 */
@objc public protocol SBObjectProtocol: NSObjectProtocol {
    func get() -> Any!
}

@objc public protocol SBApplicationProtocol: SBObjectProtocol {
    var isRunning: Bool { get }
}

@objc public protocol iTunesApplication: SBApplicationProtocol {
    @objc optional var currentTrack: iTunesTrack { get } // the current targeted track
    @objc optional var playerPosition: Double { get } // the playerâ€™s position within the currently playing track in seconds.
}

extension SBApplication: iTunesApplication {}

@objc public protocol iTunesItem: SBObjectProtocol {
    @objc optional var name: String { get } // the name of the item
}

@objc public protocol iTunesTrack: iTunesItem {
    @objc optional var album: String { get } // the album name of the track
    @objc optional var artist: String { get } // the artist/source of the track
    @objc optional var duration: Double { get } // the length of the track in seconds
}
