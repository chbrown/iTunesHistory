#!/usr/bin/env swift
import Foundation
import ScriptingBridge

/**
 Generic FileHandle wrapper with custom init and write implementations.
 */
class FileAppender {
    private var fileHandle: FileHandle

    /**
     Open file at `path`, creating blank file (with no contents and default attributes) if needed, and seek to EOF.

     - parameter path: path to file, which may or may not already exist
     */
    init(_ path: String) {
        // can't open a non-existent file for writing (um, weird?)
        if !FileManager.default.fileExists(atPath: path) {
            // create it if it doesn't exist
            // FileManager#createFile returns Bool => true if successful or already exists
            // (which might be useful?), but we'll just fail hard at FileHandle constructor step
            FileManager.default.createFile(atPath: path, contents: nil, attributes: nil)
        }
        // now open it (failing hard on I/O error, including no file existing at path)
        fileHandle = FileHandle(forWritingAtPath: path)!
        // seek to the end manually (no option to open in append mode?)
        fileHandle.seekToEndOfFile()
    }

    /**
     Append the given string to the opened file.

     - parameter line: native string to write to the file, encoded as UTF-8. Should already include newline.
     */
    func write(_ line: String) {
        // fail hard if line cannot be serialized as UTF-8
        let data = line.data(using: .utf8)!
        fileHandle.write(data)
    }
}

/*
 The following protocols are a subset of the output generated by these commands:

     sdef /Applications/iTunes.app | sdp -fh --basename iTunes  # produces "iTunes.h"
     python sbhc.py iTunes.h  # produces "iTunes.swift"

 Thanks to https://github.com/tingraldi/SwiftScripting for the sbhc.py script.

 The only protocols actively used are `iTunesApplication` and `iTunesTrack`
 */
@objc public protocol SBObjectProtocol: NSObjectProtocol {
    func get() -> Any!
}

@objc public protocol SBApplicationProtocol: SBObjectProtocol {
    var isRunning: Bool { get }
}

@objc public protocol iTunesApplication: SBApplicationProtocol {
    @objc optional var currentTrack: iTunesTrack { get } // the current targeted track
    @objc optional var playerPosition: Double { get } // the playerâ€™s position within the currently playing track in seconds.
}

extension SBApplication: iTunesApplication {}

@objc public protocol iTunesItem: SBObjectProtocol {
    @objc optional var name: String { get } // the name of the item
}

@objc public protocol iTunesTrack: iTunesItem {
    @objc optional var album: String { get } // the album name of the track
    @objc optional var artist: String { get } // the artist/source of the track
    @objc optional var duration: Double { get } // the length of the track in seconds
}

struct Track: Equatable {
    var artist: String
    var album: String
    var name: String
    var duration: Double

    init?(from: iTunesTrack?) {
        guard let artist = from?.artist, let album = from?.album, let name = from?.name, let duration = from?.duration else {
            return nil
        }
        self.artist = artist
        self.album = album
        self.name = name
        self.duration = duration
    }
}

/**
 - returns: formatted string with the following values separated by tabs, and ending with a newline:
       TIMESTAMP, COMPLETE (Y/N), ELAPSED, ARTIST, ALBUM, TRACK
   where COMPLETE is "Y" iff ELAPSED > 50% of the song's duration
 */
func formatHistoryLine(track: Track, position: Double) -> String {
    let epoch = Int(Date().timeIntervalSince1970)
    let overHalf = position > (track.duration / 2.0)
    let complete = overHalf ? "Y" : "N"
    return String(format: "%d\t%@\t%.3f\t%@\t%@\t%@\n", epoch, complete, position, track.artist, track.album, track.name)
}

func main() {
    guard let iTunes: iTunesApplication = SBApplication(bundleIdentifier: "com.apple.iTunes") else {
        print("Could not load iTunes via ScriptingBridge; exiting!")
        exit(1)
    }

    let historyFilepath = UserDefaults.standard.string(forKey: "file") ?? FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".iTunes_history").path
    let historyAppender = FileAppender(historyFilepath)
    print("Writing history to file: \(historyFilepath)")

    var previous: Track?
    var previousPosition: Double = 0.0
    let timer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
        var current: Track?
        var currentPosition: Double = 0.0
        if iTunes.isRunning {
            current = Track(from: iTunes.currentTrack)
            currentPosition = iTunes.playerPosition ?? 0.0
        }

        // if current is different from previous (including because current is nil and previous is not), log previous
        if previous != current, let track = previous {
            let historyLine = formatHistoryLine(track: track, position: previousPosition)
            historyAppender.write(historyLine)
        }

        previous = current
        previousPosition = currentPosition
    }

    let runLoop = RunLoop.main
    runLoop.add(timer, forMode: .default)
    runLoop.run()
}

main()
