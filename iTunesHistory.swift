#!/usr/bin/env swift
import Foundation
import ScriptingBridge

/**
 Generic FileHandle wrapper with custom init and write implementations.
 */
class FileAppender {
    private var fileHandle: FileHandle

    /**
     Open file at `path`, creating blank file (with no contents and default attributes) if needed, and seek to EOF.

     - parameter path: path to file, which may or may not already exist
     */
    init(_ path: String) {
        // can't open a non-existent file for writing (um, weird?)
        if !FileManager.default.fileExists(atPath: path) {
            // create it if it doesn't exist
            // FileManager#createFile returns Bool => true if successful or already exists
            // (which might be useful?), but we'll just fail hard at FileHandle constructor step
            FileManager.default.createFile(atPath: path, contents: nil, attributes: nil)
        }
        // now open it (failing hard on I/O error, including no file existing at path)
        fileHandle = FileHandle(forWritingAtPath: path)!
        // seek to the end manually (no option to open in append mode?)
        fileHandle.seekToEndOfFile()
    }

    /**
     Append the given string to the opened file.

     - parameter line: native string to write to the file, encoded as UTF-8. Should already include newline.
     */
    func write(_ line: String) {
        // fail hard if line cannot be serialized as UTF-8
        let data = line.data(using: .utf8)!
        fileHandle.write(data)
    }
}

/*
 The following protocols are a subset of the output generated by these commands:

     sdef /Applications/iTunes.app | sdp -fh --basename iTunes  # produces "iTunes.h"
     python sbhc.py iTunes.h  # produces "iTunes.swift"

 Thanks to https://github.com/tingraldi/SwiftScripting for the sbhc.py script.

 The only protocols actively used are `iTunesApplication` and `iTunesTrack`
 */
@objc public protocol SBObjectProtocol: NSObjectProtocol {
    func get() -> Any!
}

@objc public protocol SBApplicationProtocol: SBObjectProtocol {
    var isRunning: Bool { get }
}

@objc public protocol iTunesApplication: SBApplicationProtocol {
    @objc optional var currentTrack: iTunesTrack { get } // the current targeted track
    @objc optional var playerPosition: Double { get } // the playerâ€™s position within the currently playing track in seconds.
}

extension SBApplication: iTunesApplication {}

@objc public protocol iTunesItem: SBObjectProtocol {
    @objc optional var name: String { get } // the name of the item
}

@objc public protocol iTunesTrack: iTunesItem {
    @objc optional var album: String { get } // the album name of the track
    @objc optional var artist: String { get } // the artist/source of the track
    @objc optional var duration: Double { get } // the length of the track in seconds
}

class TrackState: NSObject {
    var artist: String?
    var album: String?
    var name: String?
    var duration: Double
    var position: Double

    init(fromTrack: iTunesTrack?, withPosition: Double) {
        artist = fromTrack?.artist
        album = fromTrack?.album
        name = fromTrack?.name
        duration = fromTrack?.duration ?? 0.0
        position = withPosition
    }

    /**
     - returns: true if `object`is a TrackState and both have identical artists, albums, and names
     */
    override func isEqual(_ object: Any?) -> Bool {
        if let other = object as? TrackState {
            return (artist == other.artist) && (album == other.album) && (name == other.name)
        }
        return false
    }
}

func main() {
    guard let iTunes: iTunesApplication = SBApplication(bundleIdentifier: "com.apple.iTunes") else {
        print("Could not load iTunes via ScriptingBridge; exiting!")
        exit(1)
    }

    let historyFilepath = UserDefaults.standard.string(forKey: "file") ?? FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".iTunes_history").path
    let historyAppender = FileAppender(historyFilepath)
    print("Writing history to file: \(historyFilepath)")

    var previous: TrackState?
    let timer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
        var current: TrackState?
        if iTunes.isRunning, let currentTrack = iTunes.currentTrack, let currentPosition = iTunes.playerPosition {
            current = TrackState(fromTrack: currentTrack, withPosition: currentPosition)
        }

        // ignore cases where the previous was nil or same as current
        if let previous = previous, previous != current {
            // format:
            // TIMESTAMP, COMPLETE (Y/N), ELAPSED, ARTIST, ALBUM, TRACK
            // values:
            // * COMPLETE is Y iff ELAPSED > 50% of the song's duration
            let epoch = Int(Date().timeIntervalSince1970)
            let position = previous.position
            let overHalf = position > (previous.duration / 2.0)
            let complete = overHalf ? "Y" : "N"
            if let artist = previous.artist, let album = previous.album, let name = previous.name {
                let historyLine = String(format: "%d\t%@\t%.3f\t%@\t%@\t%@\n", epoch, complete, position, artist, album, name)
                historyAppender.write(historyLine)
            }
        }

        previous = current
    }

    let runLoop = RunLoop.main
    runLoop.add(timer, forMode: .default)
    runLoop.run()
}

main()
